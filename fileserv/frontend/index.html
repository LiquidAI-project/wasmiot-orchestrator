<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset='utf-8'>
  <title>Wasm-IoT</title>
  <style>
    h1 {
      text-align: center;
    }

    body > div {
      display: flex;
      justify-content: space-around;
    }

    #form-container {
      display: flex;
      flex-direction: column;
    }

    #form-container > div {
      margin-top: 15%;
    }

    .success {
      width: 100%;
      background-color: cyan;
    }

    .error {
      width: 100%;
      background-color: red;
    }
  </style>
  <script>
    function addProcedureRow(listId) {
      /**
       * Constructor for the following HTML:
       * <li id="dprocedure-select-list-0">
       *   <label for="dprocedure-select-0">Select a procedure:</label>
       *   <select id="dprocedure-select-0" name="proc0" required>
       *     <option value="">
       *       Please select the next procedure:
       *     </option>
       *     <option value="{'device':<did0>,'module':<mid0>,'func':<fname0>}">
       *      [dName] [mName] [fName]
       *     </option>
       *     ...
       *   </select>
       * </li>
       */
      async function makeItem(id) {
        let li = document.createElement("li");
        li.id = `dprocedure-select-list-${id}`;
        let select = document.createElement("select");
        select.id = `dprocedure-select-${id}`;
        select.name = `proc${id}`;
        select.required = true;
        let label = document.createElement("label");
        label.for = select.id;
        label.textContent = "Select a procedure:";
        let option = document.createElement("option");
        option.value = "";
        option.textContent = "Please select the next procedure:";

        // Add placeholder first.
        select.appendChild(option);
        // Add all the different procedures (i.e., module exports) to be
        // selectable.
        // NOTE: Doing this way means quite a lot of requests that
        // will probably not change in between...
        // TODO: Show proc inputs and outputs for checking compatibility?
        let modulesResponse = await fetch("/file/module");
        let modulesData = await modulesResponse.json();
        let devicesResponse = await fetch("/file/device");
        let devicesData = await devicesResponse.json();

        // The null here means that selecting the device is left for orchestrator to decide.
        let anyDevice = { _id: null, name: "any device" };
        for (let device of [anyDevice].concat(devicesData)) {
          for (let mod of modulesData) {
            for (let exportt of mod.exports) {
              let exportOption = document.createElement("option");

              // Add data to the option element for parsing later and sending to the deploy-endpoint.
              let optionData = { "device": device._id, "module": mod._id, "func": exportt };
              // Saving value as a serialized JSON string, but could there be a
              // non-string solution?
              exportOption.value = JSON.stringify(optionData);
              // Make something that a human could understand from the interface.
              // TODO/FIXME?: XSS galore?
              exportOption.textContent = `Use ${device.name} for ${mod.name}:${exportt}`;

              select.appendChild(exportOption);
            }
          }
        }

        li.appendChild(label);
        li.appendChild(select);
        return li;
      }

      /**
       * Add a new row to the list-element with id `listId`.
       */
      async function handleAddRow(event) {
        event.preventDefault();

        let parentList = document.querySelector(`#${listId}`);
        let nextId = parentList.querySelectorAll("li").length;
        let newListItem = await makeItem(nextId);
        parentList.appendChild(newListItem);
      }

      return handleAddRow;
    }

    /**
     * Return a handler that submits JSON contained in a textarea-element of the
     * event target to the url.
     */
    function submitJsonTextarea(url, successCallback) {
      function handleSubmit(formSubmitEvent) {
        formSubmitEvent.preventDefault();
        let json = formSubmitEvent.target.querySelector("textarea").value;

        // Disable the form for the duration of the submission (provided it is
        // inside a fieldset-element).
        formSubmitEvent.target.querySelector("fieldset").disabled = true;
        // Submit to backend that handles application/json.
        fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: json
          })
          // TODO The backend should preferrably always respond with JSON but
          // does not currently always do so...
          .then(function(response) { return response.json(); })
          .then(function(result) {
            // Re-enable the form and show success message
            formSubmitEvent.target.querySelector("fieldset").disabled = false;
            setStatus(result);
            if (successCallback) { successCallback() };
          })
          .catch(function(result) {
            // Show an error message.
            setStatus(result);
          });
      }
      return handleSubmit;
    }

    /**
     * Using HTMLElement.dataset (See:
     * https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset),
     * create a Javascript object from the fields i.e.:
     * - text-inputs become 'key:string-value' pairs,
     * - 1-dimensional ordered lists become lists of objects (based on the
     * serialized JSON in their items' value-fields). Note: The key that then
     * corresponds to this list in the result object must be found in the
     * HTML-elements field attribute 'data-json-key'!
     */
    function formToObject(form) {
      let obj = {};
      for (let input of form.querySelectorAll("input[type=text]")) {
          // HACK: List-inputs are identified by a custom field and
          // ','-characters delimit the values.
          if ("hacktype" in input.dataset && input.dataset.hacktype === "array") {
            obj[input.name] = input.value.split(",").filter(x => x.trim().length > 0);
          } else {
            obj[input.name] = input.value;
          }
        }

        // TODO: Make a separate "arrayHandle" function.
        let ol = form.querySelector("ol");
        if (ol !== null && ol) {
          obj[ol.dataset.jsonKey] =
            // TODO: Does queryselectorall return the elements in the same
            // order as "listed" on the page?
            Array.from(ol.querySelectorAll("select"))
              // Parse the JSON-string hidden inside option.
              .map(x => JSON.parse(x.selectedOptions[0].value));
        }

        return obj;
    }

    /**
     * Transform the sourceForm's contents into JSON and put into the
     * targetTextArea.
     */
    function populateWithJson(sourceForm, targetTextArea) {
      targetTextArea.value = JSON.stringify(formToObject(sourceForm), null, 2);
    }

    /**
     * Update the form that is used to upload a Wasm-binary with the current
     * selection of modules recorded in database.
     */
    function populateWasmFormModules() {
      // Get all current modules' ids and names and add them to the list for
      // selection.
      fetch("/file/module")
        .then((resp) => resp.json())
        .then(function(modulesData) {
          let selectElem = document.querySelector("#wmodule-select");

          // Remove previous ones first and replace with newly fetched ones.
          for (let option of selectElem.querySelectorAll("option")) {
            if (option.value !== "") {
              option.remove();
            }
          }

          for (let mod of modulesData) {
            let optionElem = document.createElement("option");
            optionElem.value = mod._id;
            optionElem.textContent = mod.name;
            selectElem.appendChild(optionElem);
          }
        });
    }

    /**
     * Set the status bar to success if result.success or error if result.error
     */
    function setStatus(result) {
      let focusBar = document.querySelector("#status");
      focusBar.classList.remove("error");
      focusBar.classList.remove("success");

      if (result.success) {
        msg = result.success;
        classs = "success";
      } else {
        // Empty the message if result is malformed.
        msg = result.err ?? ("RESPONSE RESULT MALFORMED: " + JSON.stringify(result));
        // Default the style to error.
        classs = "error"
      }
      focusBar.textContent = msg;
      focusBar.classList.add(classs);
      // Scroll into view.
      focusBar.focus();
    }

    window.onload = function() {
      // Module forms:

      // Populate lists on page load.
      populateWasmFormModules();

      document.querySelector("#module-form").addEventListener("submit", (event) => { event.preventDefault(); populateWithJson(event.target, document.querySelector("#module-json-form").querySelector("textarea")); });
      document.querySelector("#module-json-form").addEventListener("submit", submitJsonTextarea("/file/module", populateWasmFormModules));

      // Deployment forms:
      document.querySelector("#dadd-procedure-row").addEventListener("click", addProcedureRow("dprocedure-sequence-list"));

      document.querySelector("#deployment-form").addEventListener("submit", (event) => { event.preventDefault(); populateWithJson(event.target, document.querySelector("#deployment-json-form").querySelector("textarea")); });
      document.querySelector("#deployment-json-form").addEventListener("submit", submitJsonTextarea("/file/manifest"));

      // Database listings:

      document.querySelector("#module-deleteall-form").addEventListener("submit", (event) => {
        event.preventDefault();
        fetch("/file/module", { method: "DELETE" })
          .then(resp => resp.json())
          .then(setStatus);
      });

      document.querySelector("#device-deleteall-form").addEventListener("submit", (event) => {
        event.preventDefault();
        fetch("/file/device", { method: "DELETE" })
          .then(resp => resp.json())
          .then(setStatus);
      });
    };
  </script>
</head>
<body>
  <h1>WasmIoT - Orchestrator</h1>
  <div>
    <h1 id="status"></h1>
  </div>
  <div>
    <div>
      <h2>Compose your application</h2>
      <div id="form-container">
        <div>
          <form id="deployment-form">
            <fieldset>
                <legend>Create a deployment</legend>
                <div>
                  <div>
                    <label for="dname">Name</label>
                    <input id="dname" name="name" required type="text" value="">
                  </div>
                  <div>
                    <p>Procedure-call sequence:</p>
                    <ol id="dprocedure-sequence-list" data-json-key="sequence">
                    </ol>
                    <button type="button" id="dadd-procedure-row">Next</button>
                  </div>
                </div>
            </fieldset>
            <input type="submit" value="To JSON"/>
          </form>
        </div>
        <div>
          <form id="deployment-json-form">
            <fieldset>
                <legend>Submit a deployment in JSON</legend>
                <div>
                  <div>
                    <textarea id="djjson" name="json" required>{}</textarea>
                  </div>
                </div>
            </fieldset>
            <input type="submit" value="Deploy!"/>
          </form>
        </div>
      </div>
    </div>
    <div>
      <ul>
        <li> 
          <a href="/file/device">Devices</a>
          <div>
          <form id="device-deleteall-form">
            <input type="submit" value="DELETE ALL DEVICES"/>
          </form>
          </div>
        </li>
        <li>
          <a href="/file/module">Modules</a>
          <form id="module-deleteall-form">
            <input type="submit" value="DELETE ALL MODULES"/>
          </form>
        </li>
        <li><a href="/file/manifest">Deployments</a></li>
      </ul>
    </div>
    <div id="form-container">
      <div>
        <form id="module-form">
          <fieldset>
            <legend>Fill-in metadata for a new module</legend>
            <div>
              <div>
                <label for="mname">Name</label>
                <input id="mname" name="name" required type="text" value="">
              </div>
            </div>
          </fieldset>
          <input type="submit" value="To JSON"/>
        </form>
      </div>
      <div>
        <form id="module-json-form">
          <fieldset>
              <legend>Submit a module in JSON</legend>
              <div>
                <div>
                  <textarea id="mjjson" name="json" required>{}</textarea>
                </div>
              </div>
          </fieldset>
          <input type="submit" value="Submit"/>
        </form>
      </div>
      <div>
        <form id="wasm-form" action="/file/module/upload" method="POST" enctype="multipart/form-data">
          <fieldset>
            <legend>Upload WebAssembly file to a module</legend>
            <div>
              <label for="wmodule-select">Select the module:</label>
              <select id="wmodule-select" name="id" required>
                <option value="">Please select an existing module:</option>
              </select>
            </div>
            <div>
              <label for="wfile">Wasm executable</label>
              <input type="file" id="wfile" name="module" required>
            </div>
          </fieldset>
          <input type="submit" value="Submit"/>
        </form>
      </div>
    </div>
  </div>
</body>
</html>